#include <stdio.h>
#include <stdint.h>
#include <string.h>

// AES S-box
// Taken from Rijndael_S-box Wikipedia
// https://en.wikipedia.org/wiki/Rijndael_S-box#Inverse_S-box
const uint8_t sbox[256] = {
        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
};

// Index 0 is unused, taken from https://en.wikipedia.org/wiki/AES_key_schedule
unsigned char Rcon[11] = {
        0x8d, 0x01, 0x02, 0x04, 0x08, 
        0x10, 0x20, 0x40, 0x80, 0x1b, 
        0x36,
};

// Galois multiplication lookup tables for MixColumns
// Taken from https://en.wikipedia.org/wiki/Rijndael_MixColumns
// p * 3 => result = galois_3[p]
unsigned char galois_2[256] = {
        0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
        0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
        0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
        0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,	
        0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
        0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
        0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
        0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
        0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,
        0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,
        0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,
        0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,
        0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,
        0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,
        0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,
        0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5
};

unsigned char galois_3[256] = {
        0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,
        0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,
        0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,
        0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,
        0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,
        0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,
        0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,
        0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,	
        0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,
        0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,
        0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,	
        0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,	
        0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,
        0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,	
        0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,
        0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a
};

unsigned char prev_expanded_key[176] = {0};

unsigned char prev_key[16] = {0};

// Shift 1 byte to the left 
// | 01 | 02 | 03 | 04 |  ->  | 02 | 03 | 04 | 01 |
void rotWord(unsigned char *word) {
    unsigned char temp;
    int i;

    temp = word[0];
    //word[3] = word[0];
    for (int i = 0; i < 3; i++)
    {
        word[i] = word[i+1];
    }
    word[3] = temp;
}

// Expands 16 byte key into 176 byte key
void keyExpansion(unsigned char *key, unsigned char *expanded_key) {
    unsigned char temp[4];
    int rcon_iteration = 1;

    int i;
    // First 16 bytes the same
    for (i = 0; i < 16; i++)
    {
        expanded_key[i] = key[i];
    }

    // Current key size in bytes
    int current_key_size = 16;
    while (current_key_size < 176) {
      // Save previous 4 bytes to temp (one word)
      for (i = 0; i < 4; i++)
      {
        temp[i] = expanded_key[(current_key_size - 4) + i];
      }

      // Every 16 bytes apply KEY SCHEDULE CORE to temp, increment iteration afterwards
      if (current_key_size % 16 == 0) {
        //Rotate word
        rotWord(temp);
        for (i = 0; i < 4; ++i)
        {
          //Substitute values from word with sbox values (SubWord)
          temp[i] = sbox[temp[i]];
        }
        //XOR rcon value of the current iteration with the leftmost part of the word
        temp[0] ^= Rcon[rcon_iteration];
        rcon_iteration++;
      }

      // XOR temp with 4 byte block 16 bytes before the new expanded key
      // This gives the next 4 bytes for the expanded key
      for (i = 0; i < 4; i++) {
        expanded_key[current_key_size] = expanded_key[current_key_size - 16] ^ temp[i];
        current_key_size++;
      }
    }
}


// Substitute values from block with value from sBox table where block value is index
void subWord(unsigned char *block) {
  for (int i = 0; i < 16; i++) {
    block[i] = sbox[block[i]];
  }
}


//  -------------------          -------------------
// | 01 | 02 | 03 | 04 |        | 01 | 02 | 03 | 04 |   no shift
// | 05 | 06 | 07 | 08 |        | 06 | 07 | 08 | 05 |   1 byte  left
// | 09 | 10 | 11 | 12 |   ->   | 11 | 12 | 09 | 10 |   2 bytes left
// | 13 | 14 | 15 | 16 |        | 16 | 13 | 14 | 15 |   3 bytes left
//  -------------------          -------------------
void shiftRows(unsigned char *block) {
  int i, j, k;
  unsigned char *row;
  unsigned char temp;
  // Iterate over the 4 rows
  // Start with i = 1 since first row is not shifted.
  for (i = 1; i < 4; i++) {
    row = block+i*4;
    // For each row, shift it to the left by the offset (i) number of bytes.
    for (j = 0; j < i; j++) {
      temp = row[0];
      for (k = 0; k < 3; k++)
      {
        row[k] = row[k+1];
      }
      row[3] = temp;
    }
  }
}


// Multiply each column field with the circulant MDS matrix:
//  ---------------
// | 2 | 3 | 1 | 1 |
// | 1 | 2 | 3 | 1 |
// | 1 | 1 | 2 | 3 |
// | 3 | 1 | 1 | 2 |
//  ---------------
// Using the Galois Multiplication lookup table
void mixColumns(unsigned char *block) {
  int i, j, k;
  unsigned char column[4];
  
  // Take columns from block
  for (i = 0; i < 4; i++)
  {
    for (j = 0; j < 4; j++)
    {
      column[j] = block[(j*4)+i];
    }

    //----------------------- Mix the column --------------------------------

    unsigned char temp[4];
    // // Copy current column into temp
    for (k = 0; k < 4; k++)
    {
      temp[k] = column[k];
    }

    // Multiply each column by the table provided above
    column[0] = galois_2[temp[0]] ^ galois_3[temp[1]] ^ temp[2] ^ temp[3];
    column[1] = temp[0] ^ galois_2[temp[1]] ^ galois_3[temp[2]] ^ temp[3];
    column[2] = temp[0] ^ temp[1] ^ galois_2[temp[2]] ^ galois_3[temp[3]];
    column[3] = galois_3[temp[0]] ^ temp[1] ^ temp[2] ^ galois_2[temp[3]];

    //--------------------------------------------------------------------------

    // Put the mixed values back into the block
    for (j = 0; j < 4; j++)
    {
      block[(j*4)+i] = column[j];
    }
  }
}

// Create round key from expanded key, then apply round key to the block
void addRoundKey(unsigned char *block, unsigned char *expanded_key, unsigned char *round_key) {
  // Create Round Key - copy next 16 bytes from the expanded key into the round key using the mapping
  int i, j;
  // Columns
  for (i = 0; i < 4; i++) {
    // Rows
    for (j = 0; j < 4; j++)
    {
      round_key[(j*4)+i] = expanded_key[(i*4)+j];
    }
  }

  // Apply round key to the block with a bitwise XOR
  for (int i = 0; i < 16; i++) {
    block[i] ^= round_key[i];
  }
}


void aesEncrypt(unsigned char *input, unsigned char *ciphertext, unsigned char *key) {
  // 10 key rounds + key = 11 * 16 = 176 bytes
  unsigned char expanded_key[176];
  if (prev_key != key) {
    //Expand key
    keyExpansion(key, expanded_key);
  } else {
    // Optimize to not do expansion if same key is used twice (not good for security)
    memcpy(expanded_key, prev_expanded_key, 176);
  }


  //16 byte block to hold plaintext
  unsigned char block[16];
  memset(block, 0, 16);

  //  Convert input into block by mapping rows of input to columns
  //  -------------------            -------------------
  // | 00 | 01 | 02 | 03 |          | 00 | 04 | 08 | 12 |
  // | 04 | 05 | 06 | 07 |   ->     | 01 | 05 | 09 | 13 |
  // | 08 | 09 | 10 | 11 |          | 02 | 06 | 10 | 14 |
  // | 12 | 13 | 14 | 15 |          | 03 | 07 | 11 | 15 |
  //  -------------------            -------------------
  int i, j;
  for (i = 0; i < 4; i++) {
    for (j = 0; j < 4; j++)
    {
      block[(j*4)+i] = input[(i*4)+j];
    }
  }

  //----------------- Encrypt block --------------------

  // 1. Create and add initial round key to block
  unsigned char round_key[16];
  addRoundKey(block, expanded_key, round_key);

  // 2. Repeat 9 rounds for 128-bit key
  for (i = 1; i < 10; i++)
  {
    subWord(block);     // a. Substitute each byte with sbox value 
    shiftRows(block);   // b. Transpose rows cyclically
    mixColumns(block);  // c. Four bytes of each column are combined using an linear transformation
    addRoundKey(block, expanded_key + 16*i, round_key); // d. Combine roundkey with block
  }
  // 3. Final 10th round
  subWord(block);
  shiftRows(block);
  addRoundKey(block, expanded_key + 16*10, round_key);

  //---------------------------------------------------

  // Reverse the mapping, put the encrypted block into ciphertext.
  for (i = 0; i < 4; i++) {
    for (j = 0; j < 4; j++)
    {
      ciphertext[(i*4)+j] = block[(j*4)+i];
    }
  }
}


int main(int argc, char *argv[])
{  
  unsigned char key[16];
  memset(key, 0, 16);
  // Read 128-bit encryption key
  fread(key, 1, 16, stdin);

  unsigned char ciphertext[16];

  unsigned char plaintext[16];
  memset(plaintext, 0, 16);

  // Read 16 bytes (one block) at a time from stdin
  while (fread(plaintext, 1, 16, stdin) == 16)
  {
    //Clear ciphertext
    memset(ciphertext, 0, 16);
    //Encrypt plaintext
    aesEncrypt(plaintext, ciphertext, key);
    //Print ciphertext in bytes
    fwrite(ciphertext, 1 , 16, stdout);
    //Clear plaintext
    memset(plaintext, 0, 16);
  }
  return 0;
}

    // Print in hex
    // for (int i = 0; i < 16; i++)
    // {
    //   //printf("%02X", ciphertext[i]);
    // }